# Лекция 8

## Структуры данных

В Python есть списки(Lists), кортежи(Tuples), словари(Dictionaries), множества(Set)
В питоне нет как таковых массивов(Array), но есть специальная библиотека, которая их создаёт.

### Списки (Lists). И немного о массивах

Списки - это структуры данных внутри которых можно хранить числа, строки, булевы значения, объекты или любые другие данные.
Списки создаются с помощью квадратных скобок `[]`. Например, присвоим переменной `li` значение список, не содержащий элементов:

```python
li = []
```

Теперь значение переменной `li` - это список. 

Можно сразу начать со списка уже заполненого какими-то значениями.

```python
other_li = [4, 5, 6]
```

У списка есть свои методы. 
Чтобы добавить зачение в список можно использовать метод списка `append`:

```python
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
```

У списка есть метод `pop`, который удаляет последнее значение в списке:

```python
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
li.append(3)    #=> [1, 2, 4, 3] - вернём элемент обратно.
```

Чтобы обратиться к элементу списка, нужно после имени переменной, в которой хранится список, поставить 
квадратные скобки и в них написать индекс элемента в списке, который мы хотим прочитать.
Например, прочитаем второй элемент списка, не забывая о том, что индекс в питоне начинается с 0, 
т.е. первый элемент имеет индекс 0, а второй уже индекс 1:

```python
li[1] #=> 2
```

Есть интересная особенность, когда с помощью отрицательного индекса можно оббратимся к последнему элементу

```python
li[-1] #=> 3
li[-2] #=> 4
```

Если попытаться использовать несуществующий, слишком большой индекс, выходящий за границы списка, выскочит ошибка индекса

```python
li[4] # Выдаёт IndexError
```

Можно не только выбирать единичные значения из списка, но и промежутки списка. Например:

```python
# Выбрать значения с индекса 1 по индекс 3 (не включая элемент по индексу 3)
li[1:3] #=> [2, 4]
# Выберем элементы, начиная с индекса 2, включительно.
li[2:] #=> [4, 3]
# Выберем элементы до 3 индеска, исключая индекс 3
li[:3] #=> [1, 2, 4]
# Выбираем каждый второй элемент
li[::2]   # =>[1, 4]
# Переворачиваем список. Т.е. выбираем элементы с шагом 1, но в обратном порядке.
li[::-1]   # => [3, 4, 2, 1]
# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]
```

Удалить произвольные элементы из списка можно оператором del. Это не метод списка, а оператор! Вы должны указать индекс, который хотите удалить.

```python
del li[2] # [1, 2, 3]
```

Списки можно складывать, или как говорят конкатенировать(соединять) при помощи `+`. Исходные списки при этом не меняются

```python
# Обратите внимание: значения li и other_li при этом не изменились.
li + other_li #=> [1, 2, 3, 4, 5, 6]  — Замечание: li и other_li не изменяются
```

Чтобы изменить список, дополнив его значениями из другого списка, используйте метод списка `extend`:

```python
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]
```

Длина списка, как и для строк вычисляется функцией len

```python
len(li) #=> 6
```

Проверить, входит ли значение в список можно с помощью оператора `in`

```python
1 in li #=> True
7 in li #=> False
```

Ничто не ограничивает хранить в списке, например, числа и строки одновременно:

```python
complex_list = [1, 2, "Hello", "world!", True]
```

Чтобы изменить элемент списка, нужно снова использовать индекс в квадратных скобках. 
Например, изменим второй элемент списка `complex_list` на строку `"Привет"`:

```python
complex_list[1] = "Привет" #=> [1, "Привет", "Hello", "world!, True]
```

В питоне есть массивы, которые очень похожи на списки, но они создаются с помощью специального модуля `array`.
Массивы могут содержать только один вид данных. Данная структуа нужна для компактного хранения таких данных. 
Вот пример создания массива c вещественным типом float(double). Каждый элемент списка занимает минимум 8 байт

```python
array('d', [1.0, 2.0, 3.14])
```

### Кортежи (Tuples)

Кортежи — это такие списки, только неизменяемые. В отличии от списков они создаются с помощью круглых скобок:

```python
# Создадим кортеж с элементами 1, 2, 3
tup = (1, 2, 3)

# Обратимся ко 2 элемента кортежа
tup[0] #=> 1

# Кортеж неизменяем, поэтому любая попытка изменить его значение приведёт к ошибке `TypeError`
tup[0] = 3  # Выдаёт TypeError
```

Всё тоже самое, что со списками(кроме изменения элементов) можно делать с кортежами:

```python
# Получить длину
len(tup) #=> 3

# Сделать конкатенацию и получить новый кортеж
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)

#  Выбрать диапазон
tup[:2] #=> (1, 2)

#  Проверить входит ли значение в кортеж
2 in tup #=> True
```

Тем не менее методов `append`, `pop`, `extend` у кортежей нет!

Несколько дополнительных вещей, которые можно делать с кортежами:

```python
# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4
```

### Словари (Dictionary)

Если необходимо, чтобы индекс в списке был не числом, а какой-то строкой - у нас есть словари.
Создаются они с помощью фигурных скобок `{}`:

```python
# пустой словарь
empty_dict = {}

# Вот так описывается предзаполненный словарь. Индексы у этого словаря уже one, two и three
filled_dict = {"one": 1, "two": 2, "three": 3}
```

Значения извлекаются так же, как из списка, с той лишь разницей, что индекс — у словарей он называется ключом — не обязан быть числом

```python
# обратимся к элементу с ключом "one"
filled_dict["one"] #=> 1
```

Все ключи в виде списка получаются с помощью метода словаря keys().
Его вызов нужно обернуть в list(), так как обратно мы получаем
итерируемый объект, о которых поговорим позднее.

```python
list(filled_dict.keys())   # => ["three", "two", "one"]
# Замечание: сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.
```

Все значения в виде списка можно получить с помощью values().
И снова нам нужно обернуть вызов в list(), чтобы превратить
итерируемый объект в список.

```python
list(filled_dict.values())   # => [3, 2, 1]
# То же самое замечание насчёт порядка ключей справедливо и здесь
```

При помощи оператора in можно проверять ключи на вхождение в словарь. Заметьте, что приверяются ключи, а не значения по этим ключам!

```python
"one" in filled_dict #=> True
1 in filled_dict #=> False
```

Попытка получить значение по несуществующему ключу выбросит ошибку ключа

```python
filled_dict["four"] # KeyError
```

Чтобы избежать этого, используйте метод get()

```python
# Получим значение по ключу "one"
filled_dict.get("one") #=> 1
# ключа "four" в словаре нет и поэтому вернется специальный объект None
filled_dict.get("four") #=> None
```

Метод get также принимает аргумент по умолчанию, значение которого будет
возвращено при отсутствии указанного ключа

```python
# ключ есть, а значит вернется значение, которое содержиться по ключу
filled_dict.get("one", 4) #=> 1
# ключа нет, а значит вернется второй аргумент метода get
filled_dict.get("four", 4) #=> 4
```

Метод setdefault вставляет пару ключ-значение, только если такого ключа нет

```python
# вставим пару ключ "five" и значение 5 в список
filled_dict.setdefault("five", 5)
# Напечатаем значение по ключу "five"
print(filled_dict["five"]) #=> печатает 5

# вставим пару ключ "five" и значение 5 в список
# Поскольку ключ уже есть - ничего не будет вставлено
filled_dict.setdefault("five", 6)
# по прежнему напечатает старое значение 6
print(filled_dict["five"]) #=> по-прежнему возвращает 5
```

Добавление элементов в словарь производится с помощью метода `update`:

```python
filled_dict.update({"four":4}) #=> {"one": 1, "two": 2, "three": 3, "four": 4}
```

Или же мы просто присваиваем значение по ключу, пусть даже несуществующему ключу

```python
filled_dict["four"] = 4  # Другой способ добавления элементов
```

Удаляйте ключи из словаря с помощью оператора del

```python
del filled_dict["one"]  # Удаляет ключ «one» из словаря
```

### Множества Set

Множества - похожи на списки, но могут содержать значение ровно один раз.Т.е. значения во множестве не повторяются!

Создать пустое множество можно с помощью функции `set()`

```python
# Создадим пустое множество
empty_set = set()
```

Для создания заполненного можества надо использовать фигурные скобки `{}`.
Это очень похоже на словарь, но без ключей!

```python
# Инициализация множества набором значений.
# Да, оно выглядит примерно как словарь… ну извините, так уж вышло.
filled_set = {1, 2, 2, 3, 4} # => {1, 2, 3, 4}
# Обратите внимание, что значение 2 во множестве не повторяется!
```

Чтобы добавить новое значение во множество надо использовать метод `add()`

```python
# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}
```

Если есть два множества, то можно найти те значения, которые содержаться и в том и в другом множестве.
Это называется пересечение и делается оператором `&`:

```python
# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}
```

Чтобы дополнить значения одного множества значением другого множества надо выполнить объединение оператором `|`

```python
# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}
```

Можно найти элементы, которые не входят в одно или другое множество. Это называется разностью и делается оператором `-`:

```python
# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}
```

Ну и наконец, проверить есть ли во множестве элемент можно оператором `in`

```python
# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False
```

